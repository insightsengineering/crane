---
title: "Hierarchical and Stratified Nested Tables"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Using functions from the {gtsummary} package we can produce nested tables and hierarchical tables commonly-used in clinical reporting.

```{r}
library(gtsummary)
theme_gtsummary_compact()
```

## Hierarchical Tables

### Event Rate Tables - `tbl_hierarchical()`

The `gtsummary::tbl_hierarchical()` function was created to create hierarchy tables, which are most commonly seen when reporting rates of adverse events (AEs). 

The `variables` argument takes a vector of variable names, where the first corresponds to the outermost hierarchy level and the last corresponds to the innermost hierarchy level. 

AE rates are calculated within each hierarchy for each level of the innermost variable. By default, summary AE rates are also calculated on label rows at each outer level of the hierarchy. This setting is controlled by the `include` argument, such that any `variable` not in `include` will not include summary AE counts. 

The `by` parameter can be used to set a single variable on which the table will be split column-wise. To include an overall row where AE rates are calculated for the overall dataset at the top of the table, set `overall_row = TRUE`.

The function reports on each row the total number of subjects with the specified AE within the current context determined by the variables specified. If multiple AEs are recorded for a single subject, all of these events are counted once for that subject. 

Unique subjects are identified via the variable supplied using the required `id` argument. 

The dataset specified via the required `denominator` argument is used to calculate the denominators in any percentage calculations as well as any `N` counts included in the table header.

Note that only *observed* combinations of hierarchy levels are included in the table - if all event rates within a given row are zero the row will be excluded.

See a basic `tbl_hierarchical()` example with a two-variable hierarchy below.

```{r tbl_hierarchical}
ADAE_subset <- cards::ADAE |>
  dplyr::filter(AEBODSYS %in% c("SKIN AND SUBCUTANEOUS TISSUE DISORDERS", "EAR AND LABYRINTH DISORDERS")) |>
  dplyr::filter(.by = AEBODSYS, dplyr::row_number() < 20)

tbl <-
  tbl_hierarchical(
    data = ADAE_subset,
    variables = c(AEBODSYS, AEDECOD),
    by = TRTA,
    denominator = cards::ADSL |> mutate(TRTA = ARM),
    id = USUBJID,
    overall_row = TRUE
  )

tbl
```

As is typical of most `tbl_*()` functions in {gtsummary}, the `tbl_hierarchical()` function also has the `statistic`, `label`, and `digits` arguments to further customize hierarchy tables. Valid statistics include `n`, `N`, and `p`. The `label` argument can specify the top-left labels for each variable as well as the label used for the "overall" row (if `overall_row = TRUE`).

See below the same example with further customization applied.

```{r tbl_hierarchical custom}
tbl <-
  tbl_hierarchical(
    data = ADAE_subset,
    variables = c(AEBODSYS, AEDECOD),
    by = TRTA,
    denominator = cards::ADSL |> mutate(TRTA = ARM),
    id = USUBJID,
    include = AEDECOD,
    digits = everything() ~ list(p = 0),
    overall_row = TRUE,
    label = list(..ard_hierarchical_overall.. = "Any Adverse Event")
  ) |>
  add_overall()

tbl
```

### Event Count Tables - `tbl_hierarchical_count()`

Similar to the `tbl_hierarchical()` function, the `tbl_hierarchical_count()` function also exists within the {gtsummary} package. 

Instead of event *rates* per subject this function calculates overall event *counts*, with no option to specify an `id` parameter. This means that events from every row of `data` will be counted, regardless of whether they occur multiple times per subject. 

If `denominator` is specified, it is only used to calculate `N` values in the table header. 

Only the `n` statistic is available when using this function.

```{r tbl_hierarchical_count}
ADAE_subset <- cards::ADAE |>
  dplyr::filter(AEBODSYS %in% c("SKIN AND SUBCUTANEOUS TISSUE DISORDERS", "EAR AND LABYRINTH DISORDERS")) |>
  dplyr::filter(.by = AEBODSYS, dplyr::row_number() < 20)

tbl <-
  tbl_hierarchical_count(
    data = ADAE_subset,
    variables = c(AEBODSYS, AEDECOD),
    by = TRTA,
    denominator = cards::ADSL |> mutate(TRTA = ARM),
    overall_row = TRUE
  )

tbl
```

### ARD-First Hierarchical Tables - `tbl_ard_hierarchical()`

In addition to the above two functions which use a data frame-first approach to creating hierarchy tables, an ARD-first approach can be taken using the `gtsummary::tbl_ard_hierarchical()` function. This function takes a hierarchical ARD object of class `"card"` and converts it to a hierarchical table. 

Hierarchical ARDs can be constructed using the `ard_stack_hierarchical()` (for event rates) and `ard_stack_hierarchical_count()` (for event counts) functions from the {cards} package.

For example:

```{r tbl_ard_hierarchical}
# Build the ARD
ard <-
  cards::ard_stack_hierarchical(
    data = ADAE_subset,
    variables = c(AESOC, AETERM),
    by = TRTA,
    denominator = cards::ADSL |> mutate(TRTA = ARM),
    id = USUBJID
  )

# Build the table from the ARD
tbl_ard_hierarchical(
  cards = ard,
  variables = c(AESOC, AETERM),
  by = TRTA
)
```

### Tables of Event Rates by Highest Severity

In addition to the standard implementation of `tbl_hierarchical()` to create tables of event rates, this function can also be used to generate tables of event rates by highest severity. This means that for each subject in `data` only one event - the event with highest severity - will be reported in the table. To do so, the innermost hierarchy variable (the last variable in `variable`) must be converted to an ordered factor variable.

For example, consider the following table:

```{r tbl_hierarchical ordered}
ADAE_subset <- cards::ADAE |>
  dplyr::filter(
    AEBODSYS %in% c("SKIN AND SUBCUTANEOUS TISSUE DISORDERS", "EAR AND LABYRINTH DISORDERS", "CARDIAC DISORDERS")
  ) |>
  dplyr::filter(.by = AEBODSYS, dplyr::row_number() < 20) |>
  dplyr::mutate(AESEV = factor(AESEV, ordered = TRUE, levels = c("MILD", "MODERATE", "SEVERE")))

tbl_hierarchical(
  data = ADAE_subset,
  variables = c(AESOC, AESEV),
  id = USUBJID,
  denominator = cards::ADSL |> dplyr::rename(TRTA = ARM),
  by = TRTA,
  overall_row = TRUE,
  label = list(AESEV = "Highest Severity")
)
```

Since each subject has exactly one event recorded for this type of table, the numbers within each hierarchy section will always add up to the numbers in the preceding summary row - for example, see in the table above that the total number of subjects with treatment Placebo in the CARDIAC DISORDERS section is 4, and the numbers within the section below, for all severity levels, also add up to 4.

### Sorting & Filtering Hierarchical Tables

Hierarchical tables can be further customized after creation by sorting and filtering them using the `gtsummary::sort_hierarchical()` and `gtsummary::filter_hierarchical()` functions, respectively.

By default, hierarchical tables are sorted alphanumerically at each level of the hierarchy. By applying the `sort_hierarchical()` function to an existing hierarchical table the sort order can be changed to "descending" - sorting rows by descending event rate/count sum at each level of the hierarchy such that the most prevalent events will be listed first.

In addition to sorting, hierarchical tables can also be filtered using `filter_hierarchical()`, which uses a given expression to filter out rows of the table. 

For examples of possible filters please see the documentation for the `filter_hierarchical()` function. 

Filtering is only applied at the innermost hierarchy level, with all summary rows from outer hierarchy levels kept. 

If all rows of a section are filtered out then the summary row for that section is also removed unless `keep_empty = TRUE` is specified. 

If the table contains an overall column then this column is ignored when filtering.

See the following example where a hierarchy table is sorted in descending order and filtered so that only rows with more than one event recorded across all treatment groups are kept.

```{r sort/filter}
tbl <-
  tbl_hierarchical(
    data = ADAE_subset,
    variables = c(AEBODSYS, AEDECOD),
    by = TRTA,
    denominator = cards::ADSL |> mutate(TRTA = ARM),
    id = USUBJID,
    overall_row = TRUE
  ) |>
  add_overall()

tbl |>
  sort_hierarchical("descending") |>
  filter_hierarchical(sum(n) > 1)
```

## Tables with Stratified Nesting - `tbl_strata_nested_stack()`

Oftentimes in clinical trial reporting we want a similar nested structure to hierarchical tables but don't want to calculate event rates or counts. 

For these calculations, we use the `gtsummary::tbl_strata_nested_stack()` function so that instead of treating the variables provided as a hierarchy they are used as nested stratifying variables. Stratified sections are then stacked to produce the full table. 

This function is similar to `tbl_strata()` but nests and indents each stratified section.

Take for example the standard laboratory results table which reports summary statistics of the `AVAL` variable stratified by the `PARAM` and `AVISIT` variables:

```{r tbl_strata_nested_stack}
ADLB_subset <- pharmaverseadam::adlb |>
  dplyr::filter(
    PARAMCD %in% c("ALB", "ALKPH"),
    AVISIT %in% c("Baseline", "Week 2", "Week 4")
  )

tbl_strata_nested_stack(
  ADLB_subset,
  strata = c(PARAM, AVISIT),
  .tbl_fun = ~ .x |>
    crane::tbl_demographics(
      include = AVAL,
      by = TRT01A,
      type = list(AVAL = "continuous2"),
      statistic = list(AVAL = c("{mean} ({sd})", "{median}", "{min} - {max}"))
    ) |>
    modify_header(all_stat_cols() ~ "**{level}**")
)
```
